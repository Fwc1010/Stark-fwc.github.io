{"meta":{"title":"Hello World","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-03-15T00:30:01.001Z","updated":"2020-03-15T00:30:01.001Z","comments":true,"path":"2020/03/15/hello-world/","link":"","permalink":"http://yoursite.com/2020/03/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"javascript的副本","slug":"javascript的副本","date":"2020-03-10T13:36:16.332Z","updated":"2020-03-15T02:22:17.523Z","comments":true,"path":"2020/03/10/javascript的副本/","link":"","permalink":"http://yoursite.com/2020/03/10/javascript%E7%9A%84%E5%89%AF%E6%9C%AC/","excerpt":"","text":"JavaScript学习笔记–廖雪峰的网站1.脚本位置：一般把JavaScript代码放到中,也可以放在文件中引入 语法笔记：第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示 Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 要判断一个属性是否是自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法 JavaScript把null、undefined、0、NaN和空字符串&#39;&#39;视为false，其他值一概视为true JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量，比如用在for循环里 ==apply==虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！ 要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 ==另一个与apply()类似的方法是call()==，唯一区别是： apply()把参数打包成Array再传入； call()把参数按顺序传入。 比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下： 12Math.max.apply(null, [3, 5, 4]); &#x2F;&#x2F; 5Math.max.call(null, 3, 5, 4); &#x2F;&#x2F; 5 对普通函数调用，我们通常把this绑定为null。 如何理解Javascript的原型和闭包（单独一文） 简单来说闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。 ==关于generator== generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。 generator和普通函数相比，有什么用？ 因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。 关于标准对象总结一下，有这么几条规则需要遵守： 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === &#39;undefined&#39;； 函数内部判断某个变量是否存在用typeof myVar === &#39;undefined&#39;。 最后有细心的同学指出，任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。 更细心的同学指出，number对象调用toString()报SyntaxError： 1123.toString(); &#x2F;&#x2F; SyntaxError 遇到这种情况，要特殊处理一下： 12123..toString(); &#x2F;&#x2F; &#39;123&#39;, 注意是两个点！(123).toString(); &#x2F;&#x2F; &#39;123&#39; 不要问为什么，这就是JavaScript代码的乐趣！ JavaScript的原型继承实现方式就是： 定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this； 借助中间函数F实现原型链继承，最好通过封装的inherits函数完成； 继续在新的构造函数的原型上定义新方法。 ES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。 你一定会问，class这么好用，能不能现在就用上？ 现在用还早了点，因为不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把class代码转换为传统的prototype代码，可以试试Babel这个工具。","categories":[],"tags":[]}]}